/**
 * Generics - это общепринятое понятие в строкотипизированных языках
 */

/* Проще всего продемонстрировать Generic на примере массива и interface 
Задекларируем массив чисел используя Generic - <>
*/

/** Напишем свой интерфейс массива
 * интерфейс MyArray принимает некий тип T в скобках <> и устанавливает тип T в index сигнатуру.
 * Т.е. generics это как аргумент у ф-ии в который принимает тип.
 */
interface MyArray<T> {
  // [N: number]: any; //если объявим таким образом то это будет не то что нужно, TS будет всё равно какое значение, какого типа мы передаём, а мы хотим указывать тип
  [N: number]: T; // при помощи T мы установили тип для этой индекс сигнатуры

  // map(fn: (el: T) => T): T[]; // определим метод map
  // map<U>(fn: (el: T) => U): U[]; // переопределили для всех типов (не только число)
  map<U>(fn: (el: T, index: number, arr: MyArray<T>) => U): MyArray<U>; // переопределили для всех типов (не только число)
}

const myArrayVar: MyArray<number> = [1, 2, 3];
/* Массив это какой-то числовой тип у которого есть числовое значение задав которое мы получаем значение, 
например так myArrayVar[123] */

/* теперь когда мы обращаемся к myArrayVar и присваиваем число 
и навести мышку на variable то увидим  тип число, 
если бы в интерфейсе оставили any то при наведении тип был бы any
*/
// let variable = myArrayVar[1]; // any
let variable = myArrayVar[1]; // number

/** если обратится к массиву методом map то он не сработает т.к. для массива myArrayVar мы создали
 * свой, некий тип Т и TS не знает что это и следовательно не знает что к нему можно применить map
 * Что бы map сработал нужно его описать в interface
 *  */
// myArrayVar.map

// после того как описали, вызываем с числами
myArrayVar.map((f: number) => f + 1); // сработало, TS видит что передали число и возвращаем число
// myArrayVar.map((f: number) => `f + ${f}`); // возвращает строку, ошибка

/* если вызвать со строками то будет ругаться потому что 
в интерфейсе мы указали что map возвращает T а он имеет тип число. Как это исправить?
В interface myArrayVar для map объявить generic который бы говорил что метод map должен возвращать
элементы того типа которые мы определили, добавим generic <U> и возвращаемое значение массив значений U
*/
[1, 2, 3].map((f: number) => `f + ${f}`); // [ 'f + 1', 'f + 2', 'f + 3' ]
myArrayVar.map((f: number) => `f + ${f}`); // ошибки больше нет, TS видит что передали число и возвращаем строку
myArrayVar.map<string>((f: number) => `f + ${f}`); // можно объявить тип для map напрямую (string), принимает строку и возвращаем строку
myArrayVar.map<number>((f: number) => `f + ${f}`); // если напрямую объявить входной тип number то будет ругаться на ошибку Т

// так же map дополнительно принимает index и array.
// Но эти аргументы нужно так же добавить в описании типа map в interface MyArray
[1, 2, 3].map((f: number, index: number, arr: number[]) => `f + ${f}`);
myArrayVar.map((f: number, index: number, arr: MyArray<number>) => `f + ${f}`);

/** на самом деле описывать interface MyArray не зачем т.к. у TS есть уже встроенный интрфейс Array
 * в котором все Generic описаны, но теперь мы знаем как это работает, пример:
 */
const myArrayVar1: Array<number> = [1, 2, 3];

/** Теперь разберемся с Generic на примере функций
 * Ф-я identitu возвращает то же самое что и принимает.
 * Если мы зададим типизацию в качестве any то мы опять не получим никих приимуществ от типизации
 */
function identity(arg: any): any {
  return arg;
}
let resul = identity(1); // при наведении покажет any

/** исправим это и зададим Generic <T> для identity1
 * Теперь  мы принимает тип аргумента и возвращаем этот же тип, получается мы опредиляем тип во время вызова ф-ии
 * а не заранее, на этапе декларирования ф-ии
 */
function identity1<T>(params: T): T {
  return params;
}
let resul1 = identity1(1); // при наведении покажет number т.к. TS определил что мы передали в ф-ю число
let resul2 = identity1(`qwerty`); // при наведении покажет string т.к. TS определил что мы передали в ф-ю строку

/** а что если нам нужен какой-то конкретный тип
 * Например мы будем возвращать длину массива т.е. возвращать число
 * Так же нам нужно ограничить ф-ю в принимаемых аргументах т.к. .length работаети для строки и для массива а нам нужен только массив
 * Для этого объявим тип принимаемого аргумента через Generic: <T extends Array<any>> - этим мы говорим что принимаемый тип Т
 * является расширением для типа массива т.е. принимаемый тип является типом массива одним из многих всех возможных типов массивов
 */
function getLen<T extends Array<any>>(arr: T): number {
  return arr.length;
}
// вызываем
getLen(`asdfgh`); // если передаём строку, то ошибка
getLen([1, 2, 3, `qwerty`]); // передаём массив, всё работает

/** Разберем ещё один пример с функциями */
/** Определим интерфейс для ф-ии
 * IValueWithType в начале стоит I это "венгерская" нотация т.к. классы JS и интерфейса TS начинаются в заглавной буквы
 * и во время их приминения они линтер сможет их разлечить но для человекочитаемости это путает, пожтому принято в интерфейсах TS
 * названия писать с I.
 * Задаём Generic <T>
 */
interface IValueWithType<T> {
  type: string;
  value: T;
}
/* Функция принимает аргумент и возвращает объект в котором содержится тип принимаемого аргумента и значение аргумента
И применяем интерфейс с Generic 
 */
function withType<U>(params: U): IValueWithType<U> {
  return {
    type: typeof params, //typeof из TS а не из JS. typeof TS возвращает строковое представление типа
    value: params,
  };
}
// вызываем
let reslt = withType(1); // let reslt: IValueWithType<number>
let reslt1 = withType(`qwert`); // let reslt1: IValueWithType<string>

/** Встроенные Generic'и */
// 1 - это Array, раннее уже говорили про него

const myArrayVar2: Array<number> = [1, 2, 3];
// 2 omit. Удаляет какое-то конкретное поле из type/interface
/** для этого примера понадобиться создать interface  */
interface IExample<T> {
  type: string;
  value: T;
  isEmpty: boolean;
}
/** omit - выкидывает из нашего интерфейса определенный ключ
 * Передадим IExample<string> и какой-либо ключ из этого интерфейса, теперь объект omittedObject
 * способен описывать только ключи type и value а isEmpty не принимает.
 * Т.е. по сути при описании объекта и использовании на этом объекте интерфейса "IExample" мы удалили из интерфейса поле "isEmpty"
 */
const omittedObject: Omit<IExample<string>, 'isEmpty'> = {
  type: `string`,
  value: `qwerty`,
  isEmpty: false, // ошибка. Объектный литерал может использовать только известные свойства. "isEmpty" не существует в типе "Omit<IExample<string>, "isEmpty">".ts(2353)
};

// 3 pick . Работает как omit только наоборот. Устанавливает "добавляет" какие-то конкретные поля из type/interface
const pickedObject: Pick<IExample<number>, 'isEmpty' | 'type'> = {
  isEmpty: false,
  type: `string`,
  value: 1, // Ошибка. Объектный литерал может использовать только известные свойства. "value" не существует в типе "Pick<IExample<number>, "isEmpty" | "type">".
};

/* 4 Partial. Делает своства interface не обязательными т.е. по сути добавляет ? к описываемым типап
interface IExample<T> {
  type?: string;
  value?: T;
  isEmpty?: boolean;
}
  но с Partial нужно быть осторожным т.к. он пораждает в коде if и придется делать проверки для не булевых типов.
*/

const partial: Partial<IExample<object>> = {};
