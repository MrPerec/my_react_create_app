/* =============================================== */
/* ================= 3.3 Объекты ================= */
/* =============================================== */
// объект может включать в себя разное множесто ключей с разными типами
const myObj: { a: number; b: string } = { a: 1, b: '2' };
const myObj0 = { a: 1, b: '2' }; // можно не указывть тип и тогда TS сам их определит
// это может работать как и type alias
type myObjType = { a: number; b: string };
const myObj1: myObjType = { a: 1, b: '2' };

// помимо описания через alias объекты описывают еще и через interface
interface MyFirstInterface {
  a: number;
  b: string;
  c: number[];
  readonly d: string; // только чтение, так достигается иммутабильность
  f?: number; // optional type. Помечаем как поле которого может и НЕ быть
  f2: number | undefined; // эта запись и предыдущая не эквиваленты, хотя TS и там и там возвращает одинаковый резултат
}
// если создадим объект с присвоенным еу опредениеим типо interface и больше ничего не напишем
// он будет ругаться что нет объявленных полей как в описанном выше интерфейсе
const myObj2: MyFirstInterface = {
  a: 2,
  b: '123',
  c: [1],
  d: 'string',
  f2: undefined, // обязательно нужно декларировать при создании обхекта, в отличии от f. Это бывает нужно когда используем Object.keys(myObj2)
};
const valueA = myObj2.a;
const valueB = myObj2.b;
const valueC = myObj2.c;
const valueD = myObj2.e; // будет ошибка т.к. свойство "d" не было описано в интерфейсе

//если попытатся присвоить значение для поля которое было описано как только для чтения то будет ошибка
myObj2.d = 'string2';

// если обращаемся к полю которого может и НЕ быть
let valueF;
if (myObj2.f) {
  valueF = myObj2.f; // будет либо указанный нами тип либо undefined (number|undefined)
}

/* работа со сложными данными, например от API пришел какой-то сложный объект у которо очено много ключей
и я не хочу описывать все эти ключа. Для такой ситуации есть indes signature */
const ApiAnswer = { key: 'asd', key1: 'asd' };
// index signature. Мы как бы сказали
// что нам всё равно к какому ключу обращаемся там есть строка и мы её хотим получить
interface IndexInterface {
  [n: string];
}
// присвоим интерфей объекту
const ApiAnswer2: IndexInterface = { key: 'asd', key1: 'asd' };
// теперь всё равно к какому ключу мы обращаемся, ошибки не будет
const value1 = ApiAnswer2.randomkey;
