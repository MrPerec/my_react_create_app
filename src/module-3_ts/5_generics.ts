/**
 * Generics - это общепринятое понятие в строкотипизированных языках
 */

/* Проще всего продемонстрировать Generic на примере массива и interface 
Задекларируем массив чисел используя Generic - <>
*/

/** Напишем свой интерфейс массива
 * если объявим таким образом то это будет не то что нужно, 
  TS будет всё равно какое значение, какого типа мы передаём, а мы хотим указывать конкретный тип
 */
interface MyArray {
  [N: number]: any; // [N: number] это index signature где обозначается что любой элемент массива (по сути ключ) имеет тип number и его значение может быть каким угодно типом
}
const myArrayVar: MyArray = [123, 123, 123]; // создали константу и применили к нему интерфейс
let myArrayItem = myArrayVar[0]; // при наведении вернет тип "any" а нам нужен конкретный тип

/** что бы получать конкретный тип допишем Generic для MyArray
 * интерфейс MyArray принимает некий тип T в скобках <> и устанавливает тип T в index сигнатуру.
 * Т.е. generics это как аргумент у ф-ии в который принимает тип.
 */
interface MyArray1<T> {
  [N: number]: T; // теперь элемент массива (по сути ключ) имеет тип который мы передали в интерфейс MyArray1 при его присвоении
}
const myArrayVar1: MyArray1<number> = [123, 123, 123]; // создали константу, применили к нему интерфейс и объявили его тип
let myArrayItem1 = myArrayVar1[1]; // при наведении теперь возвращает тип number
/** тепер у массива вызовем метод map и получим ошибку  */
myArrayVar1.map; // ошибка: "Свойство "map" не существует в типе "MyArray1<number>""

/** ошибка возникает потомучто в интерфейсе MyArray1 мы не описали этот метод, задикларируем  метод "map" в наш интерфейс 
 * что бы понимать как это сделать нужно понимание работы метода map в JS
 * Пример:
    [1, 2, 3].map((el:number)=>el+1) // -> [2, 3, 4] возврашает массив чисел
    [1, 2, 3].map((el:number)=>`el+${el}`) // -> [`el+1`, `el+2`, `el+3`] возврашает массив строк
*/
interface MyArray2<T> {
  [N: number]: T;
  /** map это метод который принимает ф-ю "fn:"
   * в качестве первого аргумента принимает итерируемый эл-т массива в который имеет тип T "(el: T)"
   * и эта функция возвращает элемент типа T "=> T"
   * и на выходе этой функции получаем массив элементов типов Т "T[]"
   */
  map(fn: (el: T) => T): T[];
}
// проверяем
const myArrayVar2: MyArray2<number> = [1, 2, 3];
const mapedArr = myArrayVar2.map((el: number) => el + 1); // метод выполнится
// а тут уже будет ошибка потому что в константе myArrayVar2 мы применяем интерфейс MyArray2 с Generic типа number а тут пытаемся получить массив строк
const mapedArr1 = myArrayVar2.map((el: number) => `el + ${el}`); // ошибка

/** что бы это иправить перепишем интерфейс MyArray2 */
interface MyArray3<T> {
  [N: number]: T;
  /* определяем Generic для метода map, "map<U>"
  и возвращать функция будет элемент этого же типа U "=> U"
  и на выходе ф-я будет возвращать массив U "U[]"
   */
  map<U>(fn: (el: T) => U): U[];
}
// проверяем
const myArrayVar3: MyArray3<number> = [1, 2, 3];
const mapedArr2 = myArrayVar3.map((el: number) => `el + ${el}`); // работает, возвращает тот тип который передается в методе map (строка)
const mapedAr3 = myArrayVar3.map((el: number) => el + 1); // с числами то же работает
const mapedArr4 = myArrayVar3.map<string>((el: number) => `el + ${el}`); // можно указать тип Generiс напрямую для метода map "<string>"
/* а если для метода map укажем "<number>" то будет ошибка потому что внутри интерфейса MyArra3 метод map видит что возвращается строка*/
const mapedArr5 = myArrayVar3.map<number>((el: number) => `el + ${el}`);

/** допишем метод map в интерфейсе MyArr т.к. по умоляанию в JS map имеет больше аргументов */
interface MyArray4<T> {
  [N: number]: T;
  /* Пример:
    [1, 2, 3].map((el:number, index:number, arr:number[]) => el + 1)

    В реализации TS добавим "index:number" он всегда числовой
    а "arr" это массив типов элементов входящего массива но для консистенции укажем "arr: MyArray4<T>"
    который возвращает элеметы такого же типа как на входе map "=> U" 
    и на выходе так же ф-я возвращает массив из элементов типов метода map "MyArray4<U>"
   */
  map<U>(fn: (el: T, index: number, arr: MyArray4<T>) => U): MyArray4<U>;
}
// проверяем
const myArrayVar4: MyArray4<number> = [1, 2, 3];
const mapedArr6 = myArrayVar4.map((el: number, index: number, arr: MyArray4<number>) => `el + ${el}`);

/** на самом деле описывать interface MyArray не зачем т.к. у TS есть уже встроенный интрфейс Array
 * в котором все Generic описаны, но теперь мы знаем как это работает, пример:
 */
const myArrayVariable: Array<number> = [1, 2, 3];

/*=========================================================================================================*/

/** Теперь разберемся с Generic на примере функций
 * Ф-я identitu возвращает то же самое что и принимает.
 * Если мы зададим типизацию в качестве any то мы опять не получим никих приимуществ от типизации
 */
function identity(arg: any): any {
  return arg;
}
let resul = identity(1); // при наведении покажет any

/** исправим это и зададим Generic <T> для identity1
 * Теперь  мы принимает тип аргумента и возвращаем этот же тип, получается мы опредиляем тип во время вызова ф-ии
 * а не заранее, на этапе декларирования ф-ии
 */
function identity1<T>(params: T): T {
  return params;
}
let resul1 = identity1(1); // при наведении покажет number т.к. TS определил что мы передали в ф-ю число
let resul2 = identity1(`qwerty`); // при наведении покажет string т.к. TS определил что мы передали в ф-ю строку

/** а что если нам нужен какой-то конкретный тип
 * Например мы будем возвращать длину массива т.е. возвращать число
 * Так же нам нужно ограничить ф-ю в принимаемых аргументах т.к. .length работаети для строки и для массива а нам нужен только массив
 * Для этого объявим тип принимаемого аргумента через Generic: <T extends Array<any>> - этим мы говорим что принимаемый тип Т
 * является расширением для типа массива т.е. принимаемый тип является типом массива одним из многих всех возможных типов массивов
 */
function getLen<T extends Array<any>>(arr: T): number {
  return arr.length;
}
// вызываем
getLen(`asdfgh`); // если передаём строку, то ошибка
getLen([1, 2, 3, `qwerty`]); // передаём массив, всё работает

/** Разберем ещё один пример с функциями */
/** Определим интерфейс для ф-ии
 * IValueWithType в начале стоит I это "венгерская" нотация т.к. классы JS и интерфейса TS начинаются в заглавной буквы
 * и во время их приминения они линтер сможет их разлечить но для человекочитаемости это путает, пожтому принято в интерфейсах TS
 * названия писать с I.
 * Задаём Generic <T>
 */
interface IValueWithType<T> {
  type: string;
  value: T;
}
/* Функция принимает аргумент и возвращает объект в котором содержится тип принимаемого аргумента и значение аргумента
И применяем интерфейс с Generic 
 */
function withType<U>(params: U): IValueWithType<U> {
  return {
    type: typeof params, //typeof из TS а не из JS. typeof TS возвращает строковое представление типа
    value: params,
  };
}
// вызываем
let reslt = withType(1); // let reslt: IValueWithType<number>
let reslt1 = withType(`qwert`); // let reslt1: IValueWithType<string>

/** Встроенные Generic'и */
// 1 - это Array, раннее уже говорили про него
const myArrayV: Array<number> = [1, 2, 3];
// 2 omit. Удаляет какое-то конкретное поле из type/interface
/** для этого примера понадобиться создать interface  */
interface IExample<T> {
  type: string;
  value: T;
  isEmpty: boolean;
}
/** omit - выкидывает из нашего интерфейса определенный ключ
 * Передадим IExample<string> и какой-либо ключ из этого интерфейса, теперь объект omittedObject
 * способен описывать только ключи type и value а isEmpty не принимает.
 * Т.е. по сути при описании объекта и использовании на этом объекте интерфейса "IExample" мы удалили из интерфейса поле "isEmpty"
 */
const omittedObject: Omit<IExample<string>, 'isEmpty'> = {
  type: `string`,
  value: `qwerty`,
  isEmpty: false, // ошибка. Объектный литерал может использовать только известные свойства. "isEmpty" не существует в типе "Omit<IExample<string>, "isEmpty">".ts(2353)
};

// 3 pick . Работает как omit только наоборот. Устанавливает "добавляет" какие-то конкретные поля из type/interface
const pickedObject: Pick<IExample<number>, 'isEmpty' | 'type'> = {
  isEmpty: false,
  type: `string`,
  value: 1, // Ошибка. Объектный литерал может использовать только известные свойства. "value" не существует в типе "Pick<IExample<number>, "isEmpty" | "type">".
};

/* 4 Partial. Делает своства interface не обязательными т.е. по сути добавляет ? к описываемым типап
interface IExample<T> {
  type?: string;
  value?: T;
  isEmpty?: boolean;
}
  но с Partial нужно быть осторожным т.к. он пораждает в коде if и придется делать проверки для не булевых типов.
*/

const partial: Partial<IExample<object>> = {};
